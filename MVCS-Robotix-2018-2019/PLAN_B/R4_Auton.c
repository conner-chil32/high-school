#pragma config(Sensor, in1,    potSelect,        sensorPotentiometer)
#pragma config(Sensor, in2,    potLift,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  encFR,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  jumper,         sensorDigitalIn)
#pragma config(Sensor, dgtl7,  encBR,          sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  encBL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl11, encFL,          sensorQuadEncoder)
#pragma config(Motor,  port2,           mBL,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           mLift,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           mIntake,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mFL,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           mFR,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           mClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mFlyWheelR,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           mFlyWheelL,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          mBR,           tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
goForward function doc
direction can be one of the four: 12, 3, 6, 9
let flyWheel be 12 o'clock
lift facing 6 o'clock, etc
*/
int mListDirection[4][13] = // 0: FL, 1: FR, 2: BL, 3: BR
{{0, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1},
	{0, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 1},
	{0, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, -1},
	{0, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1}};

int mListDrive[13][4] = {{0, 0, 0, 0},
	{0, 0, 0, 0}, {0, 0, 0, 0}, {1, 3, 0, 2},  //  3 o'clock
	{0, 0, 0, 0}, {0, 0, 0, 0}, {3, 2, 1, 0},  //  6 o'clock
	{0, 0, 0, 0}, {0, 0, 0, 0}, {2, 0, 3, 1},  //  9 o'clock
	{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 1, 2, 3}}; // 12 o'clock

int encListDrive[13][4] = {{0, 0, 0, 0},
	{0, 0, 0, 0}, {0, 0, 0, 0}, {-1, 1, 1, -1},    //  3 o'clock
	{0, 0, 0, 0}, {0, 0, 0, 0}, {-1, -1, -1, -1},  //  6 o'clock
	{0, 0, 0, 0}, {0, 0, 0, 0}, {1, -1, -1, 1},    //  9 o'clock
	{0, 0, 0, 0}, {0, 0, 0, 0}, {1, 1, 1, 1}};     // 12 o'clock

int motorPower[4] = {0, 0, 0, 0};
int encoderValues[4];

int encLeft, encRight;
void resetEncoderValues () {
	encLeft = encRight = SensorValue[encFL] = SensorValue[encFR] = SensorValue[encBL] = SensorValue[encBR] = 0;
}
void getEncoderValues (int direction) {
	encoderValues[0] = -SensorValue[encFL] * encListDrive[direction][0];
	encoderValues[1] = -SensorValue[encFR] * encListDrive[direction][1];
	encoderValues[2] =  SensorValue[encBL] * encListDrive[direction][2];
	encoderValues[3] = -SensorValue[encBR] * encListDrive[direction][3];
	encLeft = (abs(encoderValues[mListDrive[direction][0]]) + abs(encoderValues[mListDrive[direction][2]])) / 2;
	encRight = (abs(encoderValues[mListDrive[direction][1]]) + abs(encoderValues[mListDrive[direction][3]])) / 2;
}

const int encLeftRatio = 60, encRightRatio = 30;

bool encLeftGoesFurther (int direction) {
	if (direction == 12) {
		return encLeft * encLeftRatio > encRight * encRightRatio;
		} else {
		return encLeft > encRight;
	}
}

void goForward (int direction, int distance) {
	if (mListDirection[0][direction] == 0) {
		return;
	}
	resetEncoderValues();
	while ((encLeft + encRight) / 2 < distance) {
		getEncoderValues(direction);
		if (direction == 6 ? abs(encLeft * encLeftRatio - encRight * encRightRatio) : abs(encLeft - encRight) > 30) {
			motorPower[mListDrive[direction][0]] = motorPower[mListDrive[direction][2]] = encLeftGoesFurther(direction) ? 95 : 127;
			motorPower[mListDrive[direction][1]] = motorPower[mListDrive[direction][3]] = encLeftGoesFurther(direction) ? 127 : 95;
			} else {
			motorPower[0] = motorPower[1] = motorPower[2] = motorPower[3] = 127;
		}

		motor[mFL] = mListDirection[0][direction] * motorPower[0];
		motor[mFR] = mListDirection[1][direction] * motorPower[1];
		motor[mBL] = mListDirection[2][direction] * motorPower[2];
		motor[mBR] = mListDirection[3][direction] * motorPower[3];
	}
	motor[mFL] = motor[mFR] = motor[mBL] = motor[mBR] = 0;
}


void turn (int power, int distance) {
	motor[mFL] = motor[mBL] = motor[mFR] = motor[mBR] = -power;
	resetEncoderValues();
	while (abs (SensorValue[encFL]) + abs (SensorValue[encFR]) + abs (SensorValue[encBL]) + abs (SensorValue[encBR]) < distance) {
		wait1Msec(1);
	}
	motor[mFL] = motor[mBL] = motor[mFR] = motor[mBR] = power > 0 ? 35 : -35;
	wait1Msec(50);
	motor[mFL] = motor[mBL] = motor[mFR] = motor[mBR] = 0;
}
void autonBack(){
	goForward(6,200);
	motor[mLift] = 127
	motor[mIntake] = 127;
	goForward(6,700);
	motor[mIntake] = 0;
	goForward(12,200);
}

void autonLeft () {
	motor[mFlyWheelL] = motor[mFlyWheelR] = 127;
	motor[mLift] = 127;
	wait1Msec(10);
	motor[mLift] = 0;
	goForward(3,100);
	wait1Msec(2000);
	motor[mIntake] = 127;
	wait1Msec(800);
	motor[mFlyWheelL] = motor[mFlyWheelR] = 0;
	goForward(3,100);
	turn(-127,1020);
	goForward(3, 50);
	goForward(6,500);
	goForward(12,475);
	motor[mIntake] = 0;
	turn(-127, 1025);
	goForward(9, 45);
	motor[mFlyWheelL] = motor[mFlyWheelR] = 127;
	wait1Msec(2000);
	goForward(6, 200);
	wait1Msec(100);
	turn(127, 20);
	motor[mIntake] = 127;
	wait1Msec(2000);
	motor[mIntake] = motor[mFlyWheelL] = motor[mFlyWheelR] = 0;
	goForward(9, 50);
	goForward(6, 500);
	goForward(12, 450);
	/*
	goForward (12, 200);
	motor[mIntake] = 127;
	goForward (12, 200);
	wait1Msec(700);
	motor[mIntake] = 0;
	goForward (6, 100);
	turn(127,-100);
	goForward(300);
	motor[mIntake] = 127;
	motor[mFlyWheelL] = motor[mFlyWheelR] = 127;
	wait1Msec(3500);
	motor[mIntake]= 0;
	motor[mFlyWheelL] = motor[mFlyWheelR] = motor[mIntake] = 0;
	goForward (12,300);
	*/
}
void autonRight() {
	motor[mFlyWheelL] = motor[mFlyWheelR] = 127;
	motor[mLift] = 127;
	wait1Msec(10);
	motor[mLift] = 0;
	goForward(9,100);
	wait1Msec(2000);
	motor[mIntake] = 127;
	wait1Msec(800);
	motor[mFlyWheelL] = motor[mFlyWheelR] = 0;
	goForward(9,100);
	turn(127,1020);
	goForward(3, 50);
	goForward(6,500);
	goForward(12,475);
	motor[mIntake] = 0;
	turn(-127, 1025);
	goForward(3, 45);
	motor[mFlyWheelL] = motor[mFlyWheelR] = 127;
	wait1Msec(2000);
	goForward(6, 200);
	wait1Msec(100);
	turn(-127, 20);
	motor[mIntake] = 127;
	wait1Msec(2000);
	motor[mIntake] = motor[mFlyWheelL] = motor[mFlyWheelR] = 0;
	goForward(3, 50);
	goForward(6, 500);
	goForward(12, 450);
	/*
	goForward (12, 200);
	motor[mIntake] = 127;
	goForward (12, 200);
	wait1Msec(700);
	motor[mIntake] = 0;
	goForward (6, 100);
	turn(127,-100);
	goForward(300);
	motor[mIntake] = 127;
	motor[mFlyWheelL] = motor[mFlyWheelR] = 127;
	wait1Msec(3500);
	motor[mIntake]= 0;
	motor[mFlyWheelL] = motor[mFlyWheelR] = motor[mIntake] = 0;
	goForward (12,300);
	*/
}
void auton() {
	//goForward (3, 4000);
	//turn(127, 1200);
	//return;
	if (SensorValue[jumper] == 0) {
		if(SensorValue[potSelect] < 1150) {
			//autonLeft();
		} else if (SensorValue[potSelect] > 2650){
			autonRight();
		} else {
			autonBack();
		}


	}
	// else if (SensorValue[potAuton] > 2700) {
	//    autonRight();
	//}
}

task main()
{
	auton ();


}
